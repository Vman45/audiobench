DATA_TYPE TRIGGER = [BUFFER_LENGTH]BOOL;

TRIGGER global_release_trigger = FALSE;
if global_note_status == 1.0 { global_release_trigger[0] = TRUE; }
TRIGGER global_start_trigger = FALSE;
if global_note_status == 2.0 { global_start_trigger[0] = TRUE; }
BOOL global_update_feedback_data = global_should_update == 1.0;

macro FlatWaveform(buffer_pos, phase):(value) { AUTO value = 0.0; }
macro RampUpWaveform(buffer_pos, phase):(value) { AUTO value = phase * 2.0 - 1.0; }
macro RampDownWaveform(buffer_pos, phase):(value) { AUTO value = 1.0 - phase * 2.0; }
macro SineWaveform(buffer_pos, phase):(value) { AUTO value = Sin(phase * TAU); }

macro DisplayWaveform(UpdateFn, Waveform) {
    [44]FLOAT feedback;
    for i = 0 to 42 no_unroll {
        FLOAT fphase = Itof(i) / 42.0;
        feedback[i] = Waveform(0, fphase)[0?];
    }
    feedback[42] = -1.0;
    feedback[43] = -1.0;
    UpdateFn(feedback);
}

macro DisplayWaveformWithCursor(UpdateFn, Waveform, cursor_phase) {
    [44]FLOAT feedback;
    for i = 0 to 42 no_unroll {
        FLOAT fphase = Itof(i) / 42.0;
        feedback[i] = Waveform(0, fphase)[0?];
    }
    feedback[42] = cursor_phase;
    feedback[43] = Waveform(0, cursor_phase)[0?];
    UpdateFn(feedback);
}

macro DisplaySequencerPlayhead(UpdateFn, position) {
    assert position:TYPE == FLOAT;
    UpdateFn([position]);
}

macro GetTiming(SOURCE, TYPE):(timing) {
    assert SOURCE:TYPE == BOOL;
    assert TYPE:TYPE == BOOL;
    AUTO timing;
    if !SOURCE and !TYPE {
        timing = global_note_time;
    } else if SOURCE and !TYPE {
        timing = global_song_time;
    } else if !SOURCE and TYPE {
        timing = global_note_beats;
    } else if SOURCE and TYPE {
        timing = global_song_beats;
    }
}
